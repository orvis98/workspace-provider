// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f crd.yaml

package v1alpha1

import "strings"

// PublishedResource describes how an API type (usually defined by
// a CRD)
// on the service cluster should be exposed in kcp workspaces.
// Besides
// controlling how namespaced and cluster-wide resources should be
// mapped,
// the GVK can also be transformed to provide a uniform,
// implementation-independent
// access to the APIs inside kcp.
#PublishedResource: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "syncagent.kcp.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "PublishedResource"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// PublishedResourceSpec describes the desired resource
	// publication from a service
	// cluster to kcp.
	spec!: #PublishedResourceSpec
}

// PublishedResourceSpec describes the desired resource
// publication from a service
// cluster to kcp.
#PublishedResourceSpec: {
	// EnableWorkspacePaths toggles whether the Sync Agent will not
	// just store the kcp
	// cluster name as a label on each locally synced object, but also
	// the full workspace
	// path. This is optional because it requires additional requests
	// to kcp and
	// should only be used if the workspace path is of interest on the
	// service cluster side.
	enableWorkspacePaths?: bool

	// If specified, the filter will be applied to the resources in a
	// workspace
	// and allow restricting which of them will be handled by the Sync
	// Agent.
	filter?: {
		// When given, the namespace filter will be applied to a
		// resource's namespace.
		namespace?: {
			// matchExpressions is a list of label selector requirements. The
			// requirements are ANDed.
			matchExpressions?: [...{
				// key is the label key that the selector applies to.
				key!: string

				// operator represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists and DoesNotExist.
				operator!: string

				// values is an array of string values. If the operator is In or
				// NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. This array is replaced during a
				// strategic
				// merge patch.
				values?: [...string]
			}]

			// matchLabels is a map of {key,value} pairs. A single {key,value}
			// in the matchLabels
			// map is equivalent to an element of matchExpressions, whose key
			// field is "key", the
			// operator is "In", and the values array contains only "value".
			// The requirements are ANDed.
			matchLabels?: close({
				[string]: string
			})
		}

		// When given, the resource filter will be applied to a resource
		// itself.
		resource?: {
			// matchExpressions is a list of label selector requirements. The
			// requirements are ANDed.
			matchExpressions?: [...{
				// key is the label key that the selector applies to.
				key!: string

				// operator represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists and DoesNotExist.
				operator!: string

				// values is an array of string values. If the operator is In or
				// NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. This array is replaced during a
				// strategic
				// merge patch.
				values?: [...string]
			}]

			// matchLabels is a map of {key,value} pairs. A single {key,value}
			// in the matchLabels
			// map is equivalent to an element of matchExpressions, whose key
			// field is "key", the
			// operator is "In", and the values array contains only "value".
			// The requirements are ANDed.
			matchLabels?: close({
				[string]: string
			})
		}
	}

	// Mutation allows to configure "rewrite rules" to modify the
	// objects in both
	// directions during the synchronization.
	mutation?: {
		spec?: [...{
			delete?: {
				path!: string
			}
			regex?: {
				path!: string

				// Pattern can be left empty to simply replace the entire value
				// with the
				// replacement.
				pattern?:     string
				replacement?: string
			}
			template?: {
				path!:     string
				template!: string
			}
		}]
		status?: [...{
			delete?: {
				path!: string
			}
			regex?: {
				path!: string

				// Pattern can be left empty to simply replace the entire value
				// with the
				// replacement.
				pattern?:     string
				replacement?: string
			}
			template?: {
				path!:     string
				template!: string
			}
		}]
	}

	// Naming can be used to control how the namespace and names for
	// local objects
	// are formed. If not specified, the Sync Agent will use defensive
	// defaults to
	// prevent naming collisions in the service cluster.
	// When configuring this, great care must be taken to not allow
	// for naming
	// collisions to happen; keep in mind that the same name/namespace
	// can exists in
	// many different kcp workspaces.
	naming?: {
		// The name field allows to control the name the local objects
		// created by the Sync Agent.
		// If left empty, "$remoteNamespaceHash-$remoteNameHash" is
		// assumed. This guarantees unique
		// names as long as the cluster name ($remoteClusterName) is used
		// for the local namespace
		// (the default unless configured otherwise).
		// This is a string with placeholders. The following placeholders
		// can be used:
		//
		// - $remoteClusterName -- the kcp workspace's cluster name (e.g.
		// "1084s8ceexsehjm2")
		// - $remoteNamespace -- the original namespace used by the
		// consumer inside the kcp
		// workspace (if targetNamespace is left empty, it's equivalent
		// to setting "$remote_ns")
		// - $remoteNamespaceHash -- first 20 hex characters of the SHA-1
		// hash of $remoteNamespace
		// - $remoteName -- the original name of the object inside the kcp
		// workspace
		// (rarely used to construct local namespace names)
		// - $remoteNameHash -- first 20 hex characters of the SHA-1 hash
		// of $remoteName
		name?: string

		// For namespaced resources, the this field allows to control
		// where the local objects will
		// be created. If left empty, "$remoteClusterName" is assumed.
		// This is a string with placeholders. The following placeholders
		// can be used:
		//
		// - $remoteClusterName -- the kcp workspace's cluster name (e.g.
		// "1084s8ceexsehjm2")
		// - $remoteNamespace -- the original namespace used by the
		// consumer inside the kcp
		// workspace (if targetNamespace is left empty, it's equivalent
		// to setting "$remote_ns")
		// - $remoteNamespaceHash -- first 20 hex characters of the SHA-1
		// hash of $remoteNamespace
		// - $remoteName -- the original name of the object inside the kcp
		// workspace
		// (rarely used to construct local namespace names)
		// - $remoteNameHash -- first 20 hex characters of the SHA-1 hash
		// of $remoteName
		namespace?: string
	}

	// Projection is used to change the GVK of a published resource
	// within kcp.
	// This can be used to hide implementation details and provide a
	// customized API
	// experience to the user.
	// All fields in the projection are optional. If a field is set,
	// it will overwrite
	// that field in the GVK. The namespaced field can be set to turn
	// a cluster-wide
	// resource namespaced or vice-versa.
	projection?: {
		// Categories can be used to overwrite the original categories a
		// resource was in. Set
		// this to an empty list to remove all categories.
		categories?: [...string]

		// The resource Kind, for example "Database". Setting this field
		// will also overwrite
		// the singular name by lowercasing the resource kind. In
		// addition, if this is set,
		// the plural name will also be updated by taking the lowercased
		// kind name and appending
		// an "s". If this would yield an undesirable name, use the plural
		// field to explicitly
		// give the plural name.
		kind?: string

		// When overwriting the Kind, it can be necessary to also override
		// the plural name in
		// case of more complex pluralization rules.
		plural?: string

		// Whether or not the resource is namespaced.
		scope?: "Cluster" | "Namespaced"

		// ShortNames can be used to overwrite the original short names
		// for a resource, usually
		// when the Kind is remapped, new short names are also in order.
		// Set this to an empty
		// list to remove all short names.
		shortNames?: [...string]

		// The API version, for example "v1beta1".
		version?: string
	}
	related?: [...{
		// Identifier is a unique name for this related resource. The name
		// must be unique within one
		// PublishedResource and is the key by which consumers (end users)
		// can identify and consume the
		// related resource. Common names are "connection-details" or
		// "credentials".
		// The identifier must be an alphanumeric string.
		identifier!: string

		// ConfigMap or Secret
		kind!: string

		// Mutation configures optional transformation rules for the
		// related resource.
		// Status mutations are only performed when the related resource
		// originates in kcp.
		mutation?: {
			spec?: [...{
				delete?: {
					path!: string
				}
				regex?: {
					path!: string

					// Pattern can be left empty to simply replace the entire value
					// with the
					// replacement.
					pattern?:     string
					replacement?: string
				}
				template?: {
					path!:     string
					template!: string
				}
			}]
			status?: [...{
				delete?: {
					path!: string
				}
				regex?: {
					path!: string

					// Pattern can be left empty to simply replace the entire value
					// with the
					// replacement.
					pattern?:     string
					replacement?: string
				}
				template?: {
					path!:     string
					template!: string
				}
			}]
		}

		// "service" or "kcp"
		origin!: string
		reference!: {
			name!: {
				path!: string
				regex?: {
					// Pattern can be left empty to simply replace the entire value
					// with the
					// replacement.
					pattern?:     string
					replacement?: string
				}
			}
			namespace?: {
				path!: string
				regex?: {
					// Pattern can be left empty to simply replace the entire value
					// with the
					// replacement.
					pattern?:     string
					replacement?: string
				}
			}
		}
	}]

	// Describes the "source" Resource that exists on this, the
	// service cluster,
	// that should be exposed in kcp workspaces. All fields have to be
	// specified.
	resource!: {
		// The API group of a resource, for example
		// "storage.initroid.com".
		apiGroup!: string

		// The resource Kind, for example "Database".
		kind!: string

		// The API version, for example "v1beta1".
		version!: string
	}
}
